\chapter{Harpoon Commands Reference}

The information in this appendix is available online at
\url{https://beluga-lang.readthedocs.io/en/latest/harpoon/interactive-reference.html}
but is reproduced here as a way of capturing a snapshot of the features of
Harpoon at the time of writing.

This appendix gives a complete list of the interactive commands supported by
Harpoon. These commands are divided into two categories:
administractive actions
(Sec.~\ref{sec:admin-tactics}).
and
proof actions
(Sec.~\ref{sec:proof-tactics})
The former category's actions are used to obtain information from the system, to
select different subgoals, and to manipulate the history of proof actions.
The latter category's actions solve subgoals and contribute to the construction
of proof scripts.

Harpoon is structured hierarchically: a user session consists of a number of
proof sessions, each of which contains a number of theorems, each of which
contains a number of subgoals. Theorems within a proof session are proven by
mutual induction and may refer to each other, but theorems belonging to
different sessions may not refer to each other.

\section{Administrative tactics}%
\label{sec:admin-tactics}

Administrative tactics are used to navigate the proof, obtain information about
functions or constructors, or to prove a lemma in the middle of another proof.

\begin{description}
\item{\ttfamily undo}

Undoes the effect of the previous proof tactic.

\item{\ttfamily redo}

Undoes the effect of a previous \texttt{undo}.

\item{\ttfamily history}


Displays the \texttt{undo} history.

\item{\ttfamily theorem list}

Lists all theorems in the current session.

\item{\ttfamily theorem defer}

Moves the current theorem to the bottom of the theorem stack, selecting the next
theorem.

See \texttt{select} for a more flexible way to select a theorem.

\item{\ttfamily theorem show-ihs}


Display the induction hypotheses available in the current subgoal.

\textbf{Note:} this is a debugging command, and the output is not particularly
human-readable.

\item{\ttfamily theorem dump-proof PATH}

Records the current theorem's partial proof to \texttt{PATH}.

\item{\ttfamily theorem show-proof}

Displays the current theorem's partial proof.

\item{\ttfamily session list}

Lists all active sessions together with all theorems within each session.

\item{\ttfamily session defer}

Moves the current session to the bottom of the session stack and selects the
next one.

See \texttt{select} for a more flexible way to select a theorem.

\item{\ttfamily session create}

Creates a new session. This command will start the session configuration
wizard for setting up the theorems in the new session.

\item{\ttfamily session serialize}

Saves the current session as partial proofs to the signature.
In other words, any work done interactively will be reflected back into the
loaded signature.

\textbf{Note:} this will drop the current undo history.

\item{\ttfamily save}

This command is a shortcut for \texttt{session serialize}.

\item{\ttfamily subgoal list}

Lists all remaining subgoals in the current theorem.

\item{\ttfamily subgoal defer}

Moves the current subgoal to the bottom of the subgoal stack and selects the
next one.

\item{\ttfamily select}

\texttt{select NAME} selects a theorem by name for proving.
See the \texttt{session list $\langle$cmd-session-list$\rangle$} command.

\textbf{Note:} when selecting a theorem from another session, be aware of the
consequences this has on scoping.

\item{\ttfamily rename}

Renames a variable. Use \texttt{rename meta SRC DST} to rename a metavariable and
\texttt{rename comp SRC DST} to rename a program variable.

\textbf{Warning:} renaming is poorly supported at the moment!
The resulting Harpoon proof script that is generated by interactive proving
will not contain the renaming, and this could lead to accidental variable
capture.

\item{\ttfamily toggle-automation}

Use \texttt{toggle-automation AUTO [STATE]} to change the state of proof automation
features.

Valid values for \texttt{STATE} are \texttt{on}, \texttt{off}, and \texttt{toggle}. If unspecified,
\texttt{STATE} defaults to \texttt{toggle}.

\item{\ttfamily type}

Use \texttt{type EXP} to display the computed type of the given synthesizable
expression \texttt{EXP}.

\item{\ttfamily info}

Use \texttt{info KIND OBJ} to get information on the \texttt{KIND} named \texttt{OBJ}.

Valid values for \texttt{KIND} are:
\begin{description}
\item{\ttfamily theorem}

  displays information about the Beluga program or Harpoon proof
  named \texttt{OBJ}.
\end{description}
\end{description}

\section{Proof actions}%
\label{sec:proof-tactics}

These are the actions that manipulate subgoals. In general, they solve the
current subgoal, possibly replacing it with zero or more subgoals.
In case the action generates exactly one subgoal, it can be understood as
transforming the subgoal it operates on.

\begin{description}
\item{\texttt{intros}}

Use \texttt{intros [NAME...]} to introduce assumptions into the context.

Restrictions:
\begin{itemize}
\item The current goal type is either a simple or dependent function type.
\end{itemize}

For Pi-types, the name of the assumption matches the name used in the Pi. For
arrow-types, names will be taken from the given list of names, in order. If no
names are given explicitly, then names are automatically generated.

On success, this tactic will replace the current subgoal with a new subgoal in
which the assumptions are in the context.

\textbf{Note:} it is uncommon to use this tactic directly due to automation.

\item{\texttt{split}}

Use \texttt{split EXP} to perform case analysis on the synthesizable expression \texttt{EXP}.

Restrictions:
\begin{itemize}
\item The expression \texttt{EXP} and its synthesized type may not contain
  uninstantiated metavariables.
\end{itemize}

On success, this tactic removes the current subgoal and introduces a new subgoal
for every possible constructor for \texttt{EXP}.

\item{\texttt{msplit}}

Use \texttt{msplit MVAR} to perform case analysis on the metavariable \texttt{MVAR}.

This command is syntactic sugar for \texttt{split [_ |- MVAR]}.

\item{\texttt{invert}}

Use \texttt{invert EXP} to perform inversion on the synthesizable expression
\texttt{EXP}.
This is the same as using \texttt{split EXP}, but \texttt{invert} will check that a unique
case is produced.

\item{\texttt{impossible}}

Use \texttt{impossible EXP} to eliminate the uninhabited type of the synthesizable
expression \texttt{EXP}.
This is the same as using \texttt{split EXP}, but \texttt{impossible} will check that zero
cases are produced.

\item{\texttt{by}}

Use \texttt{by EXP as VAR [MODIFIER]} to invoke a lemma or induction hypothesis
represented by the synthesizable expression \texttt{EXP} and bind the result to the
name \texttt{VAR}.
The optional parameter \texttt{MODIFIER} specifies at what level the binding occurs.

Valid values for \texttt{MODIFIER} are

\begin{description}
\item{\texttt{boxed}} (default): the binding is made as a computational variable.
\item{\texttt{unboxed}}: the binding is made as a metavariable.
\item{\texttt{strengthened}}: the binding is made as a metavariable, and its context is
  strengthened according LF subordination.
\end{description}

Restrictions:
\begin{itemize}
\item The defined variable \texttt{VAR} must not already be in scope.
\item \texttt{EXP} and its synthesized type may not contain uninstantiated
  metavariables.
\item (For \texttt{unboxed} and \texttt{strengthened} only.) The synthesized
  type must be a boxed contextual object.
\end{itemize}

On success, this tactic replaces the current subgoal with a subgoal having one
additional entry in the appropriate context.

\textbf{Note.}
LF terms whose contexts contain blocks are not in principle eligible for
strengthening. But such a context is equivalent to a flat context, and Beluga
will automatically flatten any blocks when strengthening.  Therefore,
\texttt{strengthened} has a secondary use for flattening.

\item{\texttt{unbox}}

The command \texttt{unbox EXP as X} is syntactic sugar for \texttt{by EXP as X unboxed}.
See also \texttt{by}.

\item{\texttt{strengthen}}

The command \texttt{strengthen EXP as X} is syntactic sugar for \texttt{by EXP as X
strengthened}.
See also \texttt{by}.

\item{\texttt{solve}}

Use \texttt{solve EXP} to complete the proof by providing an explicit checkable
expression \texttt{EXP}.

Restrictions:

\begin{itemize}
\item The expression \texttt{EXP} must check against the current subgoal's type.
\end{itemize}

On success, this tactic removes the current subgoal, introducing no new
subgoals.

\item{\texttt{suffices}}

Use \texttt{suffices by EXP toshow TAU...} to reason backwards via the synthesizable
expression \texttt{EXP} by constructing proofs for each type annotation \texttt{TAU}.

This command captures the common situation when a lemma or computational
constructor can be used to complete a proof, because its conclusion is
(unifiable with) the subgoal's type. In this case, it \emph{suffices} to
construct the arguments to the lemma or constructor.

The main restriction on \texttt{suffices} is that the expression \texttt{EXP} must
synthesize a type of the form

\begin{lstlisting}[gobble=4]
    {X1 : U1} ... {Xn : Un} tau_1 -> ... -> tau_k -> tau
  \end{lstlisting}

Thankfully, this is the most common form of type one sees when working with
Beluga.

Restrictions:
\begin{itemize}
\item The expression \texttt{EXP} must synthesize a compatible type, as above.
\item Its target type \texttt{tau} must unify with the current goal type.
\item Each type \texttt{tau_i} must unify with the \texttt{i} th type annotation
  given in the command.
\item After unification, there must remain no uninstantiated metavariables.
\end{itemize}

\textbf{Tip.}
Sometimes, not all the type annotations are necesary to pin down the
instantiations for the Pi-bound metavariables.  Instead of a type, you can use
\texttt{_} to indicate that this type annotation should be uniquely inferrable
given the goal type and the other specified annotations. It is not uncommon to
use \texttt{suffices by i toshow _}.

\textbf{Tip.}
\texttt{suffices} eliminates both explicit and implicit leading Pi-types via
unification. It can sometimes be simpler to manually eliminate leading explicit
Pi-types via partial application: \texttt{suffices by i [C] ... toshow ...}.
When explicit Pi-types are manually eliminated, the need for a full type
annotation is less common.

On success, one subgoal is generated for each \texttt{tau_i}, and the current subgoal
is removed.

In principle, this command is redundant with \texttt{solve} because one could just
write \texttt{solve EXP} to invoke the lemma directly, but this can be quite
unwieldy if the arguments to the lemma are complicated. Furthermore, the
arguments would need to be written as Beluga terms rather than interactively
constructed.

\textbf{Warning.}
The user-provided type annotations \texttt{TAU...} are allowed to refer to
metavariables marked \texttt{(not in scope)}.  However, it is an error if an
out-of-scope metavariable appears in the instantiation for an explicitly
Pi-bound metavariable.

\end{description}

\chapter{Related work \& conclusion}

The Hazelnut system is similar to \Harpoon{} in that its metatheory formally
describes partial programs and the user interactions that construct such a
program \cite{hazelnut}.
Whereas Hazelnut concentrates on programming, \Harpoon{} is an interface to
\Beluga, a proof assistant. Hazelnut's edit actions construct a simply-typed
program by successively filling holes, and types in Hazelnut may also contain
holes that are refined by edit actions.

Abella is similar to the \Beluga{} project more broadly in that it is a
domain-specific language using HOAS for mechanizing metatheory
\cite{Gacek:IJCAR08, Gacek:JAR12}.
Its theoretical basis differs from \Beluga's, however, and it extends
first-order logic with a $\nabla$ quantifier to express properties about
variables. Contexts and simultaneous substitutions are expressed as inductive
definitions, but since they are not first-class one must separately establish
properties about them, regarding e.g. substitution composition and context
well-formedness. Interactive proof development in Abella follows the traditional
model: the proof state is manipulated using tactics drawn from a fixed set. No
proof object that witnesses the theorem is produced.

The tactic languages of VeriML \cite{Stampoulis:ICFP10,Stampoulis:POPL12} and
Coq stand in contrast to \Harpoon's, as theirs may be extended.
In VeriML, one uses an ML-like computation language to define tactics that
manipulate objects from its underlying logic language.
This computation language is very expressive, including such features as
nontermination and mutable references.
However, its management of metatheoretic concerns such as substitutions and
contexts is lower-level: one must explicitly model them, e.g. using lists.
As for Coq, its Ltac language \cite{Delahaye:LPAR00} is quite
unrestricted in its power, so Coq's typechecker must verify separately any term
built by an Ltac program.
% Consequently, it is difficult to obtain any assurance that a tactic one has
% developed is sound.
% Although user-definable tactics are a very powerful and attractive feature for a
% proof assistant, we prefer that \Harpoon{} use a fixed set of verified tactics
% until we have designed a suitable tactic development language that offers
% correctness guarantees about tactics defined in it.

In conclusion, we have presented \Harpoon, an interactive command-driven
front-end of \Beluga{} for mechanizing metatheoretic proofs.
Users develop proofs using interactive actions that elaborate a proof script
behind the scenes.
This elaboration's metatheory which we have presented shows that all
intermediate partial proofs are well-typed with respect to a context of
outstanding subgoals to resolve.
We have also developed the metatheory of proof scripts, giving a sound
translation to \Beluga{} programs.
This development relies crucially on reasoning about partial programs, which we
represent as containing contextual variables, called subgoal variables, that
capture the current typechecking state.
We have evaluated \Harpoon{} on a number of case-studies, ranging from purely
syntactic arguments to logical relations.

In the future, we aim to improve the automation capabilities of \Harpoon.
At first, we wish to add a built-in form of proof search to assist in using the
\ttsolves command, perhaps replacing it entirely. In the long term, we hope to
apply insights gained from work on Cocon \cite{cocon} to enable users to define
custom tactics together with correctness guarantees about them.

% In contrast to having users directly write dependently-typed programs
% as in Agda or Twelf, proof assistants systems such as \Coq{}
% \cite{bertot/casteran:2004} extend the approach pioneered by
% \LCF \cite{edinburgh-lcf} by having users interactively develop a proof using
% \emph{tactics}. Behind the scenes, these are elaborated into a dependently-typed
% program.
% To enable replaying the proof on demand, a sequence of tactics is recorded as a proof script.
% Ideally, applying successfully a tactic to a proof state should
% only result in a new valid, consistent proof state, but this isn't always the case:
% user-defined tactics for \Coq{} constructed in the Ltac language
% \cite{Delahaye:LPAR00} are mostly unconstrained; it is \Coq's type-checker
% that verifies post hoc that the program generated by the tactics is
% valid. In addition, tactic languages often have other caveats: they are
% low-level (for example, we might refer to an assumption by its position in the
% list of assumptions), and the resulting proof scripts are often brittle and
% unreadable.
% %As we develop a proof interactively, automatically generated variable names for assumptions are introduced and we might refer to specific meta-variables in a goal based on the total number of meta-variables and based their position. For example, 1 identifies a meta-variable appearing in the current goal, where the last meta-variable appearing is assigned number 1, the second-last assigned number 2, and so on. As a consequence, such proof scripts can be very fragile to small changes in the specification.
% %
% An alternative to this approach is the declarative style. In this style, the
% subgoal structure of the proof is retained and the scope of local names is
% explicit. This proof style is most frequently associated today with the Isar
% language \cite{isar} for the Isabelle proof assistant \cite{isabelle} and is
% meant to improve human readability of proofs. It is however also more verbose to
% use. % and does not lend itself to just getting a job done.
% %
%
%
% Some related work to be discussed:\cite{Aboul-Hosn:MKM06}
%
% \paragraph{Twelf}
%
% \cite{Pfenning99cade,Schurmann98cade}
%
%
%
% \paragraph{Interactive Theorem Proving in Agda}
% Writing dependently typed programs can be challenging. In an effort to
% reduce the effort in constructing proof terms, dependently-typed
% programming language, \Agda, offers an interactive development
% environment, integrated via the text editor  \Emacs.
% %
% For example, in the \Emacs{} mode for \Agda, the user can issue a command to
% split on a variable. \Agda{} then loads the buffer, generates the appropriate
% case analysis syntax, sends it to \Emacs, and \Emacs{} splices this code back
% into the buffer. However, there is no theoretical foundation for the
% interaction between the interactive command-driven \Emacs{} mode and \Agda.
% When the user issues a command via the \Emacs{} interface, \Agda{}
% really executes this command on the internal syntax of
% the program, which is obtained from the external syntax in the user's buffer by
% a sophisticated type reconstruction algorithm. The code resulting from the
% command, in internal syntax, must then be translated to external syntax, so
% \Emacs{} can insert it into the buffer.  Although the metatheory of the
% elaboration from external to internal syntax is
% understood~\cite{elab-dep-copat-matching}, there is no metatheory for the
% reverse direction, from internal to external syntax and there is no
% type-theoretic foundation of refining a partial proof/program.  Therefore, it is
% \todo{check that is actually the case in Agda} not uncommon to have an
% interactive command generate invalid syntax or an ill-typed code fragment. The
% interactive \Emacs{} mode for \Beluga{}, similar to \Agda's, suffered from this
% same shortcoming.

%%% Local Variables:
%%% TeX-master: "../main.tex"
%%% End:
